{"name":"Pureλi","tagline":"A purely functional, dynamically typed, parallel evaluated, lisp-like programming language","body":"Quick Start\r\n-----------\r\n\r\n### How To Install\r\n\r\nFrom source:\r\n\r\nInstall GHC 7.8.* and cabal and run the following commands:\r\n\r\n```sh\r\ngit clone https://github.com/soupi/pureli\r\ncd pureli\r\ncabal sandbox init\r\ncabal install\r\n```\r\n\r\n### How To Run\r\n\r\n#### Execution\r\n\r\nTo run the pureli REPL, write:\r\n```sh\r\npureli\r\n```\r\n\r\nTo run a pureli program, write:\r\n```sh\r\npureli <filepath>\r\n```\r\n\r\n#### Parallelism\r\n\r\nTo run with parallel execution, add `+RTS -N<n>` to the end of an execution command, where <n> is the number of core you would like to use\r\n\r\nAdding a `-s` flag will print run time information at the end of the execution.\r\n\r\n#### Example:\r\n\r\n```sh\r\npureli examples/exponent.pli +RTS -N4 -s\r\n```\r\n\r\nOr\r\n\r\n```sh\r\npureli examples/exponent.pli +RTS -N2\r\n```\r\n\r\nPureli Manual\r\n-------------\r\n\r\n![(Pureλi)](assets/pureli-light-small-transpar.png)\r\n\r\n\r\nIntroduction\r\n------------\r\n\r\nPureli is a purely functional, dynamically typed, parallel evaluated, lisp-like programming language.\r\nThese are all very big words, so let's analyze them one by one:\r\n\r\n- **Pure**: in Pureli, everything is immutable. Variables do not vary and it is not possible to destructively update data structures. Side Effects such as input and output are explicitly controlled by the programmer and can only happen in specific places.\r\n- **Functional**: Pureli follows the functional programming paradigm. In Pureli there are no loops or classes, there are recursion, modules and higher order functions.\r\n- **Dynamically Typed**: In Pureli, the types of values are checked at runtime. This makes code like this: `(if #t 1 \"hello\")` possible to run.\r\n- **Parallel Evaluated**: In Pureli, arguments to functions in pure context can be evaluated (run) in parallel automatically.\r\n- **Lisp-like**: Pureli's syntax is inherited from the long tradition of the LiSP familly of programming languages.\r\n\r\nWe will continue to explore these qualities that makes Pureli interesting and unique in future chapters.\r\n\r\nOut of the Frying Pan and into the Fire\r\n---------------------------------------\r\n\r\nLets start by learning about Pureli's Atomic Expressions.\r\n\r\nAtomic Expressions\r\n------------------\r\n\r\nAtomic expressions are expressions that cannot be evaluated any further. In Pureli, you can find:\r\n\r\n- **Integers**: Arbitrarily big integers such as (`123`, `0`, `-55192293384175798123471`)\r\n- **Reals**: Double-precision floating point numbers such as (`12.0`, `-51.5`, `0.01432`)\r\n- **Booleans**: Boolean values: `#t` for true, `#f` for false. In Pureli every value other than `#f` is `#t`.\r\n- **Strings**: Text strings such as (`\"Hello world!\"`, `\"Pureλi is Great!\"`)\r\n- **Symbols**: Symbols are used as names for values and functions. (`x`, `lines->str`, `print!`) are symbols that evaluates to variables and functions.\r\n- **Keywords**: Keywords are like Symbols, only that they always evaluated to themselves. They are useful for passing flags to functions or as keys for a dictionary. (`:hello`, `:x`, `:always-start-with-colons`)\r\n- **Nil**: Nil is like `void`, `Unit` or `()` in other languages. (`nil`, `()`)\r\n\r\n\r\nSyntax\r\n------\r\n\r\n![Lisp](lisp_cycles.png)\r\n\r\nPureli derives it's syntax from LiSP, a family of programming languages with similar syntax and attributes.\r\n\r\nLiSP, as it's name, is about List Processing. In lisp, everything is either an atomic expression or a list,\r\nwhich is denoted by parenthesis.\r\n\r\nFor example:\r\n```rkt\r\n(this is a list)\r\n```\r\n\r\nLists can be nested:\r\n```rkt\r\n(this is a (list inside (a list)))\r\n```\r\n\r\nLisp uses polish notation. When evaluated, the first argument serves as a command and the rests are arguments:\r\n```rkt\r\n(+ 32 1 942 444)\r\n```\r\n\r\nExpressions can be nested as well:\r\n```rkt\r\n(+ 32 1 942 (+ 111 222 1 110))\r\n```\r\n\r\nTo stop an expressions from evaluating we use the command `quote`:\r\n```rkt\r\n(quote (+ 2 2 3)) ;; => '(+ 2 2 3)\r\n```\r\n\r\nIt's result will be a data structure with these arguments, which can be evaluated using `eval`.\r\n```rkt\r\n(eval (quote (+ 2 2 3))) ;; => 7\r\n```\r\n\r\nSince the result of `quote` expression is a data structure, a list, we can use list operations such as\r\n`car`, `cdr`, and `++` to manipulate it:\r\n```rkt\r\n(eval (++ '(*) (cdr (quote (+ 2 2 3))))) ;; => 12\r\n```\r\n\r\n**In Pureli (and Lisp), code __is__ data!**\r\n\r\n\r\nDefining Things\r\n---------------\r\n\r\nWe use `define` to bind names to expressions:\r\n```rkt\r\n(define x (+ 1 2 3))\r\n```\r\n\r\nWe can create our own anonymous functions using `lambda`:\r\n\r\n```rkt\r\n((lambda (x y) (+ x y)) 2 3) ;; => 5\r\n```\r\n\r\nIf we want to create a function and give it a name, we can use `define`:\r\n\r\n```rkt\r\n(define f\r\n  (lambda (x y) (+ x y)))\r\n```\r\n\r\nOr use another form of `define` which is just a syntactic sugar:\r\n```rkt\r\n(define f (x y)\r\n  (+ x y))\r\n```\r\n\r\n`define` can only be used to introduce a name at the top level of a module, which will make it available to the entire module.\r\n\r\nFor local definitions, We can use `let` and `letrec`:\r\n```rkt\r\n(let ([x 5] [y 1]) (+ x y)) ;; => 6\r\n\r\n(letrec ([loop (lambda () (loop))]) (loop)) ;; => <infinite-loop>\r\n\r\n(let ([loop (lambda () (loop))]) (loop)) ;; => error. cannot find x in environment\r\n```\r\n\r\n\r\n### Unevaluated parameters\r\n\r\nIt is also possible to define functions with receives unevaluated parameters\r\n\r\n```rkt\r\n\r\n(module main)\r\n\r\n(define first-element (~x)\r\n  (eval (car 'x)))\r\n\r\n  (first-element (:hello (error \"will not be thrown\"))) ;; => :hello\r\n\r\n```\r\n\r\nFunctions with Unevaluated parameters are useful when we want to expand the language\r\nand are Pureli's alternative for simple macros.\r\n\r\n\r\nModules\r\n-------\r\n\r\n### Definition\r\n\r\nIt is possible to define multiple modules per file. In order to run a file, a 'main' module must be present.\r\n\r\nSyntax: `(module <name> ?(<exported definitions>))`\r\n\r\n- `(<exported definitions>)` will only export definitions listed. Optional.\r\n\r\n\r\n\r\n### Requires\r\n\r\nIt is possible to import a source file using the `require` keyword at the top of the module. Cyclic imports are currently not allowed.\r\n\r\nSyntax: `(require <filepath> <module name> ?(<imported definitions>) <?new name>)`\r\n\r\nOr when required module is in the same file: `(module <name>)`\r\n\r\n- `(<imported definitions>)` will only imported definitions listed. Optional.\r\n- `<new name>` will give the module a new name. Optional.\r\n- A definition from a module can be accessed using `/`.\r\n\r\n\r\nI/O\r\n---\r\n\r\nI/O handling in Pureli might be a bit different from what you are used to.\r\nSince most functions in pureli are pure, the cannot have side-effects.\r\nThis means that you need to separate pure computations from impure computations in your code, this is how you do it:\r\n\r\n- The entry point, `main` in the module `main`, starts as impure\r\n- Chaining impure actions are done with `do!`\r\n- Lifting a pure computation into impure context is done with `pure`\r\n- `let!` is used to bind a result from impure context to a name\r\n\r\nExample:\r\n\r\n```rkt\r\n\r\n(module main)\r\n\r\n(define main\r\n  (do!\r\n    (print! \"calculating the sum of 1, 2 and 3:\") ;; print! is impure\r\n    (let! result (pure (+ 1 2 3))) ;; pure lifts (+ 1 2 3) into impure context and let! binds it to result\r\n    (print! result))) ;; print! prints the result\r\n\r\n```\r\n\r\nThis separation is useful for a number of things:\r\n\r\n- Separating concerns\r\n- Safety from state changes\r\n- Modularity\r\n- Testability\r\n- Freedom to parallelize!\r\n\r\n\r\n\r\nBuilt-in Procedures\r\n-------------------\r\n\r\n- Arithmetic operations (`+`, `-`, `*`, `/`, `mod`)\r\n- Tests (`zero?`, `empty?`, `nil?`, `number?`, `integer?`, `real?`, `list?`. `string?`, `procedure?`, `symbol?`, `keyword?`)\r\n- Comparison (`=`, `<>`, `>`, `<`, `>=`, `<=`)\r\n- List operations (`list`, `car`, `cdr`)\r\n- List and String operations (`++`, `slice`, `length`)\r\n- String operations (`str->lines`, `str->words`, `lines->str`, `words->str`, `to-upper`, `to-lower`)\r\n- `round` operation on reals\r\n- `show` expression\r\n- `if` expression\r\n- `let` and `letrec`\r\n- `quote`, `eval` and `read-str`\r\n- `error`, `try` and `trace`\r\n- `lambda` expression\r\n\r\n### Built-in IO Actions\r\n\r\n- `do!` sequence IO actions\r\n- `let!` binds an IO result to a variable\r\n- `read!` reads a line from the standard input\r\n- `read-file!` reads a file\r\n- `print!` writes a line to the standard output\r\n- `print-file!` writes a string to a file\r\n- `pure` raises a pure computation into IO context\r\n\r\nStandard Library Modules\r\n------------------------\r\n\r\n- `std`\r\n- `list`\r\n- `bool`\r\n- `numbers`\r\n- `dict`\r\n\r\nUse `(require \"stdlib/std.pli\" <module-name>)` to import modules from the standard library.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}