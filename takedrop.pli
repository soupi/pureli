(module main)

(defmacro cond
  [() (error "*** error: cond - non-exhuastive patterns")]
  [(clause1 &rest)
    (if (eval (car 'clause1))
      (eval (car (cdr 'clause1)))
      (cond &rest))])

(define cons (x xs)
  (++ (list x) xs))

(define take (lst i)
  (if (> i 0)
      (slice 0 i lst)
      ()))

(define drop (lst i)
  (if (> i 0)
      (drop (cdr lst) (- i 1))
      lst))

(define part (lst i)
  (list (take lst i)
        (drop lst i)))

(define mergelists (left right)
  (cond
    '((empty? left) right)
    '((empty? right) left)
    '((< (car left) (car right))
      (cons (car left) (mergelists (cdr left) right)))
    '(#t
      (cons (car right) (mergelists left (cdr right))))))

(define mergesort (lst)
  (if (> 2 (length lst))
    lst
    (let ([x (/ (length lst) 2)])
        (mergelists (mergesort (take lst x))
                     (mergesort (drop lst x))))))

(defmacro apply
  ((op lst)
   (eval (++ (list op) lst))))

(define max lst
  (cond
    ((empty? (cdr lst)) (car lst))
    ((>= (car lst) (apply max (cdr lst)))(car lst))
    (#t (apply max (cdr lst)))))

(define min lst
  (cond
    ((empty? (cdr lst)) (car lst))
    ((<= (car lst) (apply min (cdr lst)))(car lst))
    (#t (apply min (cdr lst)))))

(define abs (x)
  (if (< x 0) (* x -1) x))

(define gcd (a b)
  (cond ((= b 0) a)
        (#t (gcd b (mod a b)))))
(define lcm (a b)
  (/ (* (abs a) (abs b)) (gcd a b)))

(define not [test]
  (if test #f #t))

(define filter [f xs]
  (if (not (list? xs))
    (error "cannot filter on a non list type")
    (if (empty? xs)
      xs
      (if (f (car xs)) (cons (car xs) (filter f (cdr xs))) (filter f (cdr xs))))))

(define fold [f xs init]
  (if (not (list? xs))
    (error "cannot fold on a non list type")
    (if (empty? xs)
      init
      (f (car xs) (fold f (cdr xs) init)))))

(define index
    (lambda (lst place)
      (if (nil? lst)
          ()
          (if (> place (length lst))
          (error "place is out of bound for list given")
          (if (< place 0)
          (error "place cannot be smaller than 0 for list given")
          (if (= place 0)
          (car lst)
          (index (cdr lst) (- place 1))))))))

(define reverse (xs)
  (if (empty? xs)
    xs
    (++ (reverse (cdr xs)) (list(car xs)))))

(define main
  (do!
    [print! (reverse (list 1 2 3 4 5))]
    [print! (index (list 1 2 3 4) 1)]
    [print! (filter integer? (list 1 2 3 1.3))]
    [print! (fold + (list 1 2 3 4) 0)]
    [print! (max 1 2 3 -1)]
    [print! (gcd 1024 516)]
    [print! (lcm 12 18)]
    [let! result (pure (min 1 2 5 -1))]
    [print! "Merge List Result:"]
    [print! result]))
